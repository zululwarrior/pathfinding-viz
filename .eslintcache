[{"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\index.tsx":"1","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\reportWebVitals.ts":"2","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\App.tsx":"3","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\algorithms\\dijkstra.tsx":"4","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\dijkstra\\DijkstraGrid.tsx":"5","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\dijkstra\\DijkstraNode.tsx":"6","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\helperFunctions.tsx":"7","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\gridComponents.tsx":"8","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\astar\\AStarGrid.tsx":"9","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\astar\\AStarNode.tsx":"10","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\algorithms\\aStar.tsx":"11","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\algorithms\\mazeGenerator.tsx":"12","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\util.tsx":"13","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\global.tsx":"14"},{"size":478,"mtime":1608214246136,"results":"15","hashOfConfig":"16"},{"size":425,"mtime":499162500000,"results":"17","hashOfConfig":"16"},{"size":2004,"mtime":1611198265979,"results":"18","hashOfConfig":"16"},{"size":1614,"mtime":1608758610546,"results":"19","hashOfConfig":"16"},{"size":9045,"mtime":1608917390866,"results":"20","hashOfConfig":"16"},{"size":2927,"mtime":1608756553494,"results":"21","hashOfConfig":"16"},{"size":335,"mtime":1608914942955,"results":"22","hashOfConfig":"16"},{"size":247,"mtime":1608915699963,"results":"23","hashOfConfig":"16"},{"size":9169,"mtime":1608917427032,"results":"24","hashOfConfig":"16"},{"size":3040,"mtime":1608741358803,"results":"25","hashOfConfig":"16"},{"size":2696,"mtime":1608830569769,"results":"26","hashOfConfig":"16"},{"size":3276,"mtime":1608754188504,"results":"27","hashOfConfig":"16"},{"size":1389,"mtime":1608917377493,"results":"28","hashOfConfig":"16"},{"size":250,"mtime":1611198196969,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"16ctfyx",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"32"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"32"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"32"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"32"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"57"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\index.tsx",[],["64","65"],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\reportWebVitals.ts",[],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\App.tsx",[],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\algorithms\\dijkstra.tsx",[],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\dijkstra\\DijkstraGrid.tsx",["66","67"],"import React, { useState, useEffect } from 'react';\r\n\r\nimport Node from './DijkstraNode';\r\nimport { dijkstra } from '../../algorithms/dijkstra';\r\nimport { createGrid } from '../../helperFunctions';\r\nimport { GridComponent, GridCol } from '../gridComponents';\r\nimport generateMaze from '../../algorithms/mazeGenerator';\r\nimport { Button, ButtonGroup, ResetButtonGroup } from '../util';\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  distance: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst DijkstraGrid: React.FC = () => {\r\n  const [startNodeCoords, setStartNodeCoords] = useState({ x: 7, y: 1 });\r\n  const [endNodeCoords, setEndNodeCoords] = useState({ x: 7, y: 28 });\r\n\r\n  const createNode = (x: number, y: number): node => {\r\n    return {\r\n      start: x === startNodeCoords.y && y === startNodeCoords.x,\r\n      end: x === endNodeCoords.y && y === endNodeCoords.x,\r\n      x,\r\n      y,\r\n      weight: 1,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n      visited: false,\r\n      isWall: false,\r\n      shortest: false,\r\n    };\r\n  };\r\n\r\n  const [grid, setGrid] = useState(createGrid<node>(createNode));\r\n  const [isClicked, setIsClicked] = useState(false);\r\n  const [isWeight, setIsWeight] = useState(false);\r\n  const [isStart, setIsStart] = useState(false);\r\n  const [isEnd, setIsEnd] = useState(false);\r\n  const [isMaze, setIsMaze] = useState(false);\r\n  const [isAnimationComplete, setIsAnimationComplete] = useState(false);\r\n\r\n  const [startNode, setStartNode] = useState(\r\n    grid[startNodeCoords.x][startNodeCoords.y]\r\n  );\r\n  const [endNode, setEndNode] = useState(\r\n    grid[endNodeCoords.x][endNodeCoords.y]\r\n  );\r\n\r\n  useEffect(() => {\r\n    setStartNode(grid[startNodeCoords.x][startNodeCoords.y]);\r\n    setEndNode(grid[endNodeCoords.x][endNodeCoords.y]);\r\n    if (isMaze) {\r\n      generateMaze(grid);\r\n      setIsMaze(false);\r\n    }\r\n  }, [startNodeCoords, endNodeCoords, grid]);\r\n\r\n  const mouseDown = (x: number, y: number, isWeight: boolean) => {\r\n    setIsClicked(true);\r\n    grid[x][y].start ? setIsStart(true) : setIsStart(false);\r\n    grid[x][y].end ? setIsEnd(true) : setIsEnd(false);\r\n\r\n    if (grid[x][y].start || grid[x][y].end)\r\n      makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseEnter = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    if (isStart || isEnd) makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseUp = (x: number, y: number) => {\r\n    setIsClicked(false);\r\n    setIsStart(false);\r\n    setIsEnd(false);\r\n  };\r\n\r\n  const mouseLeave = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    resetNode(x, y, isStart, isEnd);\r\n  };\r\n\r\n  const resetNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      const newNode = { ...node, start: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      const newNode = { ...node, end: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const makeStartOrEndNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      setStartNodeCoords({ x, y });\r\n      const newNode = { ...node, start: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newNode,\r\n          newGrid[endNodeCoords.x][endNodeCoords.y]\r\n        );\r\n      }\r\n      return;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      setEndNodeCoords({ x, y });\r\n      const newNode = { ...node, end: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newGrid[startNodeCoords.x][startNodeCoords.y],\r\n          newNode\r\n        );\r\n      }\r\n      return;\r\n    }\r\n  };\r\n  const redrawAlgorithm = (grid: node[][], start: node, end: node) => {\r\n    emptyGrid();\r\n    const visitedNodes = dijkstra(grid, start, end);\r\n    const closestPath = getClosestPath(end);\r\n    for (let j = 0; j < closestPath!.length; j++) {\r\n      setGrid((currGrid) => {\r\n        const newGrid = [...currGrid];\r\n        const node = closestPath![j];\r\n        const end = {\r\n          ...node,\r\n          shortest: true,\r\n        };\r\n        newGrid[node.y][node.x] = end;\r\n        return newGrid;\r\n      });\r\n    }\r\n  };\r\n\r\n  const setNode = (x: number, y: number, isWeight: boolean) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (!isWeight) {\r\n      const newNode = { ...node, isWall: !node.isWall };\r\n      newGrid[x][y] = newNode;\r\n    } else {\r\n      let newNode;\r\n      node.weight > 1\r\n        ? (newNode = { ...node, weight: 1 })\r\n        : (newNode = { ...node, weight: 10 });\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isAnimationComplete) {\r\n      redrawAlgorithm(\r\n        newGrid,\r\n        newGrid[startNodeCoords.x][startNodeCoords.y],\r\n        newGrid[endNodeCoords.x][endNodeCoords.y]\r\n      );\r\n    }\r\n  };\r\n\r\n  const toggleWeight = () => {\r\n    setIsWeight(!isWeight);\r\n  };\r\n\r\n  const resetGrid = () => {\r\n    setGrid(createGrid<node>(createNode));\r\n    setStartNode(grid[startNodeCoords.x][startNodeCoords.y]);\r\n    setEndNode(grid[endNodeCoords.x][endNodeCoords.y]);\r\n    setIsAnimationComplete(false);\r\n  };\r\n\r\n  const getClosestPath = (endNode: node) => {\r\n    const closestPath: node[] = [];\r\n    let currNode: node | null = endNode;\r\n    while (currNode !== null) {\r\n      closestPath.unshift(currNode);\r\n      currNode = currNode.previousNode;\r\n    }\r\n    return closestPath;\r\n  };\r\n\r\n  const emptyGrid = () => {\r\n    const newGrid = [...grid];\r\n    newGrid.forEach((col) => {\r\n      col.forEach((node) => {\r\n        node.visited = false;\r\n        node.shortest = false;\r\n        node.distance = Infinity;\r\n        node.previousNode = null;\r\n      });\r\n    });\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const animateClosestPath = (closestPath: node[], i: number) => {\r\n    setTimeout(() => {\r\n      for (let j = 0; j < closestPath.length; j++) {\r\n        setTimeout(() => {\r\n          setGrid((grid) => {\r\n            const newGrid = [...grid];\r\n            const node = closestPath[j];\r\n            const newNode = {\r\n              ...node,\r\n              shortest: true,\r\n            };\r\n            newGrid[node.y][node.x] = newNode;\r\n            return newGrid;\r\n          });\r\n        }, 30 * j);\r\n      }\r\n      setIsAnimationComplete(true);\r\n    }, 30 * i);\r\n  };\r\n\r\n  const animateDijkstra = (visitedNodes: node[], i: number) => {\r\n    setTimeout(() => {\r\n      setGrid((grid) => {\r\n        const newGrid = [...grid];\r\n        const node = visitedNodes![i];\r\n        const newNode = {\r\n          ...node,\r\n          visited: true,\r\n        };\r\n        newGrid[node.y][node.x] = newNode;\r\n        return newGrid;\r\n      });\r\n    }, 30 * i);\r\n  };\r\n\r\n  const visualiseDijkstra = () => {\r\n    emptyGrid();\r\n    const visitedNodes = dijkstra(grid, startNode, endNode);\r\n    const closestPath = getClosestPath(endNode);\r\n    emptyGrid();\r\n    for (let i = 0; i < visitedNodes!.length; i++) {\r\n      if (i === visitedNodes!.length - 1) {\r\n        animateClosestPath(closestPath, i);\r\n      }\r\n      animateDijkstra(visitedNodes!, i);\r\n    }\r\n  };\r\n\r\n  const createMaze = () => {\r\n    setGrid(createGrid<node>(createNode));\r\n    setIsAnimationComplete(false);\r\n    setIsMaze(true);\r\n  };\r\n\r\n  let nodeObjectData: any = {\r\n    mouseDown,\r\n    mouseEnter,\r\n    mouseUp,\r\n    mouseLeave,\r\n    isWeight,\r\n  };\r\n  const weightOrWallText = isWeight ? 'weight' : 'wall';\r\n  return (\r\n    <>\r\n      <ButtonGroup>\r\n        <Button onClick={visualiseDijkstra}>Animate</Button>\r\n        <Button onClick={toggleWeight}>{weightOrWallText}</Button>\r\n        <Button onClick={createMaze}>maze</Button>\r\n      </ButtonGroup>\r\n      <GridComponent>\r\n        {grid.map((col, i) => (\r\n          <GridCol key={i}>\r\n            {col.map((node, j) => {\r\n              nodeObjectData = { ...nodeObjectData, ...node };\r\n              if (node.x === startNode.x && node.y === startNode.y)\r\n                return (\r\n                  <Node data={{ ...nodeObjectData, start: true }} key={j} />\r\n                );\r\n\r\n              if (node.x === endNode.x && node.y === endNode.y)\r\n                return <Node data={{ ...nodeObjectData, end: true }} key={j} />;\r\n\r\n              return <Node data={nodeObjectData} key={j} />;\r\n            })}\r\n          </GridCol>\r\n        ))}\r\n      </GridComponent>\r\n      <ResetButtonGroup>\r\n        <Button onClick={resetGrid}>reset</Button>\r\n      </ResetButtonGroup>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default DijkstraGrid;\r\n","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\dijkstra\\DijkstraNode.tsx",["68","69","70"],"import React, { useState, useEffect } from 'react';\r\nimport styled, { keyframes, css } from 'styled-components';\r\n\r\ninterface Props {\r\n  props: node;\r\n}\r\n\r\ninterface MainProps {\r\n  data: node;\r\n}\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  distance: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  mouseDown: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseEnter: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseUp: (x: number, y: number) => void;\r\n  mouseLeave: (x: number, y: number, w: boolean) => void;\r\n  isWeight: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst NodeAnimation = keyframes`\r\n  0% {transform:scale(0)}\r\n  20% {transform:scale(0.3)}\r\n  40% {transform:scale(0.6)}\r\n  60% {transform:scale(0.9)}\r\n  80%{transform:scale(1.1)}\r\n  100%{transform:scale(1.0)}\r\n`;\r\n\r\nconst NodeOutline = styled.div`\r\n  width: 30px;\r\n  height: 30px;\r\n  margin: 1px;\r\n  user-select: none;\r\n  -webkit-user-drag: none;\r\n`;\r\n\r\nconst NodeComponent = styled.div<Props>`\r\n  position: relative;\r\n  background-color: ${(props) =>\r\n    props.props.start\r\n      ? 'green'\r\n      : props.props.end\r\n      ? 'red'\r\n      : props.props.isWall\r\n      ? 'pink'\r\n      : props.props.shortest\r\n      ? 'blue'\r\n      : props.props.weight > 1 && props.props.visited\r\n      ? 'gold'\r\n      : props.props.weight > 1\r\n      ? 'grey'\r\n      : props.props.visited\r\n      ? 'yellow'\r\n      : 'transparent'};\r\n  width: 100%;\r\n  height: 100%;\r\n  animation: ${(props) =>\r\n    props.props.start || props.props.end\r\n      ? `none`\r\n      : props.props.visited || props.props.shortest\r\n      ? css`\r\n          ${NodeAnimation} 1s linear\r\n        `\r\n      : `none`};\r\n`;\r\n\r\nconst ShortestNode = styled(NodeComponent)<Props>``;\r\n\r\nconst Node: React.FC<MainProps> = ({ data }) => {\r\n  const { x, y, isWeight, shortest, start, end } = data;\r\n\r\n  return (\r\n    <NodeOutline>\r\n      {(shortest && (\r\n        <ShortestNode\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight);\r\n          }}\r\n        />\r\n      )) || (\r\n        <NodeComponent\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight);\r\n          }}\r\n        />\r\n      )}\r\n    </NodeOutline>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\helperFunctions.tsx",[],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\gridComponents.tsx",[],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\astar\\AStarGrid.tsx",["71","72"],"import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nimport Node from './AStarNode';\r\nimport { aStar } from '../../algorithms/aStar';\r\nimport generateMaze from '../../algorithms/mazeGenerator';\r\nimport { createGrid } from '../../helperFunctions';\r\nimport { Button, ButtonGroup, ResetButtonGroup } from '../util';\r\n\r\nconst GridComponent = styled.div`\r\n  border: solid 1px;\r\n`;\r\n\r\nconst GridCol = styled.div`\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n`;\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  gScore: number;\r\n  fScore: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst AStarGrid: React.FC = () => {\r\n  const [startNodeCoords, setStartNodeCoords] = useState({ x: 7, y: 1 });\r\n  const [endNodeCoords, setEndNodeCoords] = useState({ x: 7, y: 28 });\r\n\r\n  const createNode = (x: number, y: number): node => {\r\n    return {\r\n      start: x === startNodeCoords.y && y === startNodeCoords.x,\r\n      end: x === endNodeCoords.y && y === endNodeCoords.x,\r\n      x,\r\n      y,\r\n      weight: 0,\r\n      gScore: Infinity,\r\n      fScore: Infinity,\r\n      previousNode: null,\r\n      visited: false,\r\n      isWall: false,\r\n      shortest: false,\r\n    };\r\n  };\r\n\r\n  const [grid, setGrid] = useState(createGrid<node>(createNode));\r\n  const [isClicked, setIsClicked] = useState(false);\r\n  const [isWeight, setIsWeight] = useState(false);\r\n  const [isStart, setIsStart] = useState(false);\r\n  const [isEnd, setIsEnd] = useState(false);\r\n  const [isMaze, setIsMaze] = useState(false);\r\n  const [isAnimationComplete, setIsAnimationComplete] = useState(false);\r\n\r\n  const [startNode, setStartNode] = useState(\r\n    grid[startNodeCoords.x][startNodeCoords.y]\r\n  );\r\n  const [endNode, setEndNode] = useState(\r\n    grid[endNodeCoords.x][endNodeCoords.y]\r\n  );\r\n\r\n  useEffect(() => {\r\n    setStartNode(grid[startNodeCoords.x][startNodeCoords.y]);\r\n    setEndNode(grid[endNodeCoords.x][endNodeCoords.y]);\r\n    if (isMaze) {\r\n      generateMaze(grid);\r\n      setIsMaze(false);\r\n    }\r\n  }, [startNodeCoords, endNodeCoords, grid]);\r\n\r\n  const mouseDown = (x: number, y: number, isWeight: boolean) => {\r\n    setIsClicked(true);\r\n    grid[x][y].start ? setIsStart(true) : setIsStart(false);\r\n    grid[x][y].end ? setIsEnd(true) : setIsEnd(false);\r\n    if (grid[x][y].start || grid[x][y].end)\r\n      makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseEnter = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    if (isStart || isEnd) makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseUp = (x: number, y: number) => {\r\n    setIsClicked(false);\r\n    setIsStart(false);\r\n    setIsEnd(false);\r\n  };\r\n\r\n  const mouseLeave = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    resetNode(x, y, isStart, isEnd);\r\n  };\r\n\r\n  const resetNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      const newNode = { ...node, start: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      const newNode = { ...node, end: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const makeStartOrEndNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      setStartNodeCoords({ x, y });\r\n      const newNode = { ...node, start: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newNode,\r\n          newGrid[endNodeCoords.x][endNodeCoords.y]\r\n        );\r\n      }\r\n      return;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      setEndNodeCoords({ x, y });\r\n      const newNode = { ...node, end: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newGrid[startNodeCoords.x][startNodeCoords.y],\r\n          newNode\r\n        );\r\n      }\r\n      return;\r\n    }\r\n  };\r\n\r\n  const setNode = (x: number, y: number, isWeight: boolean) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (!isWeight) {\r\n      const newNode = { ...node, isWall: !node.isWall };\r\n      newGrid[x][y] = newNode;\r\n    } else {\r\n      let newNode;\r\n      node.weight > 0\r\n        ? (newNode = { ...node, weight: 0 })\r\n        : (newNode = { ...node, weight: 10 });\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isAnimationComplete) {\r\n      redrawAlgorithm(\r\n        newGrid,\r\n        newGrid[startNodeCoords.x][startNodeCoords.y],\r\n        newGrid[endNodeCoords.x][endNodeCoords.y]\r\n      );\r\n    }\r\n  };\r\n\r\n  const toggleWeight = () => {\r\n    setIsWeight(!isWeight);\r\n  };\r\n\r\n  const resetGrid = () => {\r\n    setIsAnimationComplete(false);\r\n    setGrid(createGrid<node>(createNode));\r\n  };\r\n\r\n  const getClosestPath = (endNode: node) => {\r\n    const closestPath: node[] = [];\r\n    let currNode: node | null = endNode;\r\n    while (currNode !== null) {\r\n      closestPath.unshift(currNode);\r\n      currNode = currNode.previousNode;\r\n    }\r\n    return closestPath;\r\n  };\r\n\r\n  const emptyGrid = () => {\r\n    const newGrid = [...grid];\r\n    newGrid.forEach((col) => {\r\n      col.forEach((node) => {\r\n        node.visited = false;\r\n        node.shortest = false;\r\n        node.shortest = false;\r\n        node.fScore = Infinity;\r\n        node.gScore = Infinity;\r\n        node.previousNode = null;\r\n      });\r\n    });\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const animateClosestPath = (closestPath: node[], i: number) => {\r\n    setTimeout(() => {\r\n      for (let j = 0; j < closestPath.length; j++) {\r\n        setTimeout(() => {\r\n          setGrid((grid) => {\r\n            const newGrid = [...grid];\r\n            const node = closestPath[j];\r\n            const newNode = {\r\n              ...node,\r\n              shortest: true,\r\n            };\r\n            newGrid[node.y][node.x] = newNode;\r\n            return newGrid;\r\n          });\r\n        }, 50 * j);\r\n      }\r\n      setIsAnimationComplete(true);\r\n    }, 50 * i);\r\n  };\r\n\r\n  const animateAStar = (visitedNodes: node[], i: number) => {\r\n    setTimeout(() => {\r\n      setGrid((grid) => {\r\n        const newGrid = [...grid];\r\n        const node = visitedNodes![i];\r\n        const newNode = {\r\n          ...node,\r\n          visited: true,\r\n        };\r\n        newGrid[node.y][node.x] = newNode;\r\n        return newGrid;\r\n      });\r\n    }, 50 * i);\r\n  };\r\n\r\n  const visualiseAStar = () => {\r\n    emptyGrid();\r\n    const visitedNodes = aStar(grid, startNode, endNode);\r\n    const closestPath = getClosestPath(endNode);\r\n    emptyGrid();\r\n    for (let i = 0; i < visitedNodes!.length; i++) {\r\n      if (i === visitedNodes!.length - 1) {\r\n        animateClosestPath(closestPath, i);\r\n      }\r\n      animateAStar(visitedNodes!, i);\r\n    }\r\n  };\r\n\r\n  const redrawAlgorithm = (grid: node[][], start: node, end: node) => {\r\n    emptyGrid();\r\n    const visitedNodes = aStar(grid, start, end);\r\n    console.log(grid);\r\n    const closestPath = getClosestPath(end);\r\n    for (let j = 0; j < closestPath!.length; j++) {\r\n      setGrid((currGrid) => {\r\n        const newGrid = [...currGrid];\r\n        const node = closestPath![j];\r\n        const end = {\r\n          ...node,\r\n          shortest: true,\r\n        };\r\n        newGrid[node.y][node.x] = end;\r\n        return newGrid;\r\n      });\r\n    }\r\n  };\r\n\r\n  let nodeObjectData: any = {\r\n    mouseDown,\r\n    mouseEnter,\r\n    mouseUp,\r\n    mouseLeave,\r\n    isWeight,\r\n  };\r\n\r\n  const createMaze = () => {\r\n    setGrid(createGrid<node>(createNode));\r\n    setIsAnimationComplete(false);\r\n    setIsMaze(true);\r\n  };\r\n  const weightOrWallText = isWeight ? 'weight' : 'wall';\r\n\r\n  return (\r\n    <>\r\n      <ButtonGroup>\r\n        <Button onClick={visualiseAStar}>Animate</Button>\r\n        <Button onClick={toggleWeight}>{weightOrWallText}</Button>\r\n        <Button onClick={createMaze}>maze</Button>\r\n      </ButtonGroup>\r\n      <GridComponent>\r\n        {grid.map((col, i) => (\r\n          <GridCol key={i}>\r\n            {col.map((node, j) => {\r\n              nodeObjectData = { ...nodeObjectData, ...node };\r\n              if (node.x === startNode.x && node.y === startNode.y)\r\n                return (\r\n                  <Node data={{ ...nodeObjectData, start: true }} key={j} />\r\n                );\r\n\r\n              if (node.x === endNode.x && node.y === endNode.y)\r\n                return <Node data={{ ...nodeObjectData, end: true }} key={j} />;\r\n\r\n              return <Node data={nodeObjectData} key={j} />;\r\n            })}\r\n          </GridCol>\r\n        ))}\r\n      </GridComponent>\r\n      <ResetButtonGroup>\r\n        <Button onClick={resetGrid}>reset</Button>\r\n      </ResetButtonGroup>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default AStarGrid;\r\n","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\astar\\AStarNode.tsx",["73","74"],"import React, { useState, useEffect } from 'react';\r\nimport styled, { keyframes, css } from 'styled-components';\r\n\r\ninterface Props {\r\n  props: node;\r\n}\r\n\r\ninterface MainProps {\r\n  data: node;\r\n}\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  distance: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  mouseDown: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseEnter: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseUp: (x: number, y: number) => void;\r\n  mouseLeave: (\r\n    x: number,\r\n    y: number,\r\n    w: boolean,\r\n    s: boolean,\r\n    e: boolean\r\n  ) => void;\r\n  isWeight: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst NodeAnimation = keyframes`\r\n  0% {transform:scale(0)}\r\n  20% {transform:scale(0.3)}\r\n  40% {transform:scale(0.6)}\r\n  60% {transform:scale(0.9)}\r\n  80%{transform:scale(1.1)}\r\n  100%{transform:scale(1.0)}\r\n`;\r\n\r\nconst NodeOutline = styled.div`\r\n  width: 30px;\r\n  height: 30px;\r\n  margin: 1px;\r\n  user-select: none;\r\n  -webkit-user-drag: none;\r\n`;\r\n\r\nconst NodeComponent = styled.div<Props>`\r\n  position: relative;\r\n  background-color: ${(props) =>\r\n    props.props.start\r\n      ? 'green'\r\n      : props.props.end\r\n      ? 'red'\r\n      : props.props.isWall\r\n      ? 'pink'\r\n      : props.props.shortest\r\n      ? 'blue'\r\n      : props.props.weight > 1 && props.props.visited\r\n      ? 'gold'\r\n      : props.props.weight > 1\r\n      ? 'grey'\r\n      : props.props.visited\r\n      ? 'yellow'\r\n      : 'transparent'};\r\n  width: 100%;\r\n  height: 100%;\r\n  animation: ${(props) =>\r\n    props.props.start || props.props.end\r\n      ? `none`\r\n      : props.props.visited || props.props.shortest\r\n      ? css`\r\n          ${NodeAnimation} 1s linear\r\n        `\r\n      : `none`};\r\n`;\r\n\r\nconst ShortestNode = styled(NodeComponent)<Props>``;\r\n\r\nconst Node: React.FC<MainProps> = ({ data }) => {\r\n  const { x, y, isWeight, shortest, start, end } = data;\r\n\r\n  return (\r\n    <NodeOutline>\r\n      {(shortest && (\r\n        <ShortestNode\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            console.log(start);\r\n\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight, start, end);\r\n          }}\r\n        />\r\n      )) || (\r\n        <NodeComponent\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight, start, end);\r\n          }}\r\n        />\r\n      )}\r\n    </NodeOutline>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\algorithms\\aStar.tsx",[],["75","76"],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\algorithms\\mazeGenerator.tsx",[],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\components\\util.tsx",[],"C:\\Users\\asbina\\Desktop\\programming_exercise\\test\\algo-viz\\src\\global.tsx",[],{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","severity":1,"message":"82","line":64,"column":6,"nodeType":"83","endLine":64,"endColumn":44,"suggestions":"84"},{"ruleId":"85","severity":1,"message":"86","line":154,"column":11,"nodeType":"87","messageId":"88","endLine":154,"endColumn":23},{"ruleId":"85","severity":1,"message":"89","line":1,"column":17,"nodeType":"87","messageId":"88","endLine":1,"endColumn":25},{"ruleId":"85","severity":1,"message":"90","line":1,"column":27,"nodeType":"87","messageId":"88","endLine":1,"endColumn":36},{"ruleId":"85","severity":1,"message":"91","line":80,"column":44,"nodeType":"87","messageId":"88","endLine":80,"endColumn":47},{"ruleId":"81","severity":1,"message":"82","line":76,"column":6,"nodeType":"83","endLine":76,"endColumn":44,"suggestions":"92"},{"ruleId":"85","severity":1,"message":"86","line":270,"column":11,"nodeType":"87","messageId":"88","endLine":270,"endColumn":23},{"ruleId":"85","severity":1,"message":"89","line":1,"column":17,"nodeType":"87","messageId":"88","endLine":1,"endColumn":25},{"ruleId":"85","severity":1,"message":"90","line":1,"column":27,"nodeType":"87","messageId":"88","endLine":1,"endColumn":36},{"ruleId":"77","replacedBy":"93"},{"ruleId":"79","replacedBy":"94"},"no-native-reassign",["95"],"no-negated-in-lhs",["96"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'isMaze'. Either include it or remove the dependency array.","ArrayExpression",["97"],"@typescript-eslint/no-unused-vars","'visitedNodes' is assigned a value but never used.","Identifier","unusedVar","'useState' is defined but never used.","'useEffect' is defined but never used.","'end' is assigned a value but never used.",["98"],["95"],["96"],"no-global-assign","no-unsafe-negation",{"desc":"99","fix":"100"},{"desc":"99","fix":"101"},"Update the dependencies array to be: [startNodeCoords, endNodeCoords, grid, isMaze]",{"range":"102","text":"103"},{"range":"104","text":"103"},[1984,2022],"[startNodeCoords, endNodeCoords, grid, isMaze]",[2160,2198]]
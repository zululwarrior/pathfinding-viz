{"version":3,"sources":["components/dijkstra/DijkstraNode.tsx","algorithms/dijkstra.tsx","helperFunctions.tsx","components/gridComponents.tsx","algorithms/mazeGenerator.tsx","components/util.tsx","components/dijkstra/DijkstraGrid.tsx","components/astar/AStarNode.tsx","algorithms/aStar.tsx","components/astar/AStarGrid.tsx","global.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["NodeAnimation","keyframes","NodeOutline","styled","div","NodeComponent","props","start","end","isWall","shortest","weight","visited","css","ShortestNode","Node","data","x","y","isWeight","onMouseDown","mouseDown","onMouseEnter","mouseEnter","onMouseUp","mouseUp","onMouseLeave","mouseLeave","dijkstra","grid","distance","visitedNodes","unvisitedNodes","flat","closestNode","sortNodesByClosest","shift","undefined","Infinity","push","getNeighbours","filter","neighbour","forEach","previousNode","nodes","sort","a","b","node","neighbours","length","createGrid","createNode","col","GridComponent","GridCol","updateGrid","cell","bottomWall","console","log","rightWall","mergeSets","leftId","rightId","amountInSet","cells","i","size","id","set","get","createUniqueSet","amountsInSet","generateMaze","numCols","numRows","currRow","Map","newGrid","j","createWall","Math","random","removeBottomWall","amount","Button","button","SelectionButton","selection","algorithmName","ButtonGroup","ResetButtonGroup","DijkstraGrid","useState","startNodeCoords","setStartNodeCoords","endNodeCoords","setEndNodeCoords","setGrid","isClicked","setIsClicked","setIsWeight","isStart","setIsStart","isEnd","setIsEnd","isMaze","setIsMaze","isAnimationComplete","setIsAnimationComplete","startNode","setStartNode","endNode","setEndNode","useEffect","resetNode","newNode","makeStartOrEndNode","redrawAlgorithm","emptyGrid","closestPath","getClosestPath","currGrid","setNode","currNode","unshift","animateClosestPath","setTimeout","animateDijkstra","nodeObjectData","weightOrWallText","onClick","map","aStar","openSet","Set","gScore","fScore","shortestDistance","add","closedSet","currentNode","Array","from","delete","has","tenativeGScore","totalDist","AStarGrid","animateAStar","GlobalStyles","createGlobalStyle","MainContainer","Container","App","setCurrGrid","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.31ec9c19.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport styled, { keyframes, css } from 'styled-components';\r\n\r\ninterface Props {\r\n  props: node;\r\n}\r\n\r\ninterface MainProps {\r\n  data: node;\r\n}\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  distance: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  mouseDown: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseEnter: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseUp: (x: number, y: number) => void;\r\n  mouseLeave: (x: number, y: number, w: boolean) => void;\r\n  isWeight: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst NodeAnimation = keyframes`\r\n  0% {transform:scale(0)}\r\n  20% {transform:scale(0.3)}\r\n  40% {transform:scale(0.6)}\r\n  60% {transform:scale(0.9)}\r\n  80%{transform:scale(1.1)}\r\n  100%{transform:scale(1.0)}\r\n`;\r\n\r\nconst NodeOutline = styled.div`\r\n  width: 30px;\r\n  height: 30px;\r\n  margin: 1px;\r\n  user-select: none;\r\n  -webkit-user-drag: none;\r\n`;\r\n\r\nconst NodeComponent = styled.div<Props>`\r\n  position: relative;\r\n  background-color: ${(props) =>\r\n    props.props.start\r\n      ? 'green'\r\n      : props.props.end\r\n      ? 'red'\r\n      : props.props.isWall\r\n      ? 'pink'\r\n      : props.props.shortest\r\n      ? 'blue'\r\n      : props.props.weight > 1 && props.props.visited\r\n      ? 'gold'\r\n      : props.props.weight > 1\r\n      ? 'grey'\r\n      : props.props.visited\r\n      ? 'yellow'\r\n      : 'transparent'};\r\n  width: 100%;\r\n  height: 100%;\r\n  animation: ${(props) =>\r\n    props.props.start || props.props.end\r\n      ? `none`\r\n      : props.props.visited || props.props.shortest\r\n      ? css`\r\n          ${NodeAnimation} 1s linear\r\n        `\r\n      : `none`};\r\n`;\r\n\r\nconst ShortestNode = styled(NodeComponent)<Props>``;\r\n\r\nconst Node: React.FC<MainProps> = ({ data }) => {\r\n  const { x, y, isWeight, shortest, start, end } = data;\r\n\r\n  return (\r\n    <NodeOutline>\r\n      {(shortest && (\r\n        <ShortestNode\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight);\r\n          }}\r\n        />\r\n      )) || (\r\n        <NodeComponent\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight);\r\n          }}\r\n        />\r\n      )}\r\n    </NodeOutline>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","interface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  distance: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n}\r\n\r\ntype grid = node[][];\r\n\r\nexport const dijkstra = (grid: grid, start: node, end: node) => {\r\n  start.distance = 0;\r\n  start.start = true;\r\n  end.end = true;\r\n  const visitedNodes: node[] = [];\r\n  const unvisitedNodes = grid.flat();\r\n\r\n  while (!!unvisitedNodes) {\r\n    const closestNode = sortNodesByClosest(unvisitedNodes).shift();\r\n    if (closestNode !== undefined) {\r\n      if (closestNode.isWall) continue;\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.visited = true;\r\n      visitedNodes.push(closestNode);\r\n      if (closestNode === end) return visitedNodes;\r\n      const neighbours = getNeighbours(closestNode, grid);\r\n      neighbours\r\n        .filter((neighbour) => !neighbour.visited)\r\n        .forEach((neighbour) => {\r\n          neighbour.distance = closestNode.distance + neighbour.weight;\r\n          neighbour.previousNode = closestNode;\r\n        });\r\n    }\r\n  }\r\n};\r\n\r\nconst sortNodesByClosest = (nodes: node[]) => {\r\n  return nodes.sort((a, b) => {\r\n    return a.distance - b.distance;\r\n  });\r\n};\r\n\r\nconst getNeighbours = (node: node, grid: grid) => {\r\n  const neighbours: node[] = [];\r\n  const { x, y } = node;\r\n\r\n  if (y < grid.length - 1) neighbours.push(grid[y + 1][x]);\r\n  if (y > 0) neighbours.push(grid[y - 1][x]);\r\n  if (x < grid[0].length - 1) neighbours.push(grid[y][x + 1]);\r\n  if (x > 0) neighbours.push(grid[y][x - 1]);\r\n  return neighbours;\r\n};\r\n","type createNode<T> = (x: number, y: number) => T;\r\n\r\nconst createGrid = <T,>(createNode: createNode<T>) => {\r\n  const grid = [];\r\n  for (let y = 0; y < 16; y++) {\r\n    const col = [];\r\n    for (let x = 0; x < 30; x++) {\r\n      col.push(createNode(x, y));\r\n    }\r\n    grid.push(col);\r\n  }\r\n  return grid;\r\n};\r\n\r\nexport { createGrid };\r\n","import styled from 'styled-components';\r\n\r\nconst GridComponent = styled.div`\r\n  border: solid 1px;\r\n`;\r\n\r\nconst GridCol = styled.div`\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n`;\r\n\r\nexport { GridCol, GridComponent };\r\n","type node = any;\r\n\r\ninterface cell {\r\n  bottomWall: boolean;\r\n  rightWall: boolean;\r\n  id: number;\r\n}\r\n\r\ntype grid = node[][];\r\n\r\nconst generateMaze = (grid: grid) => {\r\n  let numCols = grid[0].length;\r\n  let numRows = grid.length;\r\n  let currRow: cell[] = [];\r\n  let amountInSet = new Map<number, number>();\r\n  const newGrid = [...grid];\r\n\r\n  for (let i = 0; i < numCols; i++) {\r\n    amountInSet.set(i, 0);\r\n    currRow.push({ rightWall: false, bottomWall: true, id: -1 });\r\n  }\r\n\r\n  for (let i = 0; i < numRows; i += 2) {\r\n    for (let j = 0; j < currRow.length; j += 3) {\r\n      createUniqueSet(amountInSet, currRow[j]);\r\n    }\r\n\r\n    for (let j = 0; j < currRow.length; j += 3) {\r\n      if (j === currRow.length - 1) {\r\n        break;\r\n      }\r\n      if (currRow[j].id === currRow[j + 1].id) {\r\n        currRow[j].rightWall = true;\r\n      } else {\r\n        const createWall = Math.random() >= 0.5;\r\n        currRow[j].rightWall = createWall;\r\n        if (!createWall)\r\n          mergeSets(currRow[j].id, currRow[j + 1].id, amountInSet, currRow);\r\n      }\r\n    }\r\n\r\n    for (let j = 0; j < currRow.length; j++) {\r\n      let removeBottomWall = Math.random() >= 0.5;\r\n      if (amountInSet.get(currRow[j].id) === 1) removeBottomWall = true;\r\n      currRow[j].bottomWall = !removeBottomWall;\r\n      if (!removeBottomWall) {\r\n        amountInSet.set(currRow[j].id, amountInSet.get(currRow[j].id)! - 1);\r\n      }\r\n    }\r\n    if (i !== numRows - 1) {\r\n      amountInSet.forEach((amount) => {\r\n        amount = 0;\r\n      });\r\n      for (let j = 0; j < currRow.length; j++) {\r\n        updateGrid(newGrid, i, j, currRow[j]);\r\n        currRow[j].rightWall = false;\r\n        if (currRow[j].bottomWall) currRow[j].id = -1;\r\n        else\r\n          amountInSet.set(currRow[j].id, amountInSet.get(currRow[j].id)! + 1);\r\n        currRow[j].bottomWall = true;\r\n      }\r\n    }\r\n  }\r\n  return newGrid;\r\n};\r\n\r\nconst updateGrid = (grid: grid, x: number, y: number, cell: cell) => {\r\n  if (x < grid.length) {\r\n    if (cell.bottomWall) {\r\n      console.log(grid[x + 1][y].start);\r\n      if (!grid[x + 1][y].start && !grid[x + 1][y].end)\r\n        grid[x + 1][y].isWall = true;\r\n    }\r\n  }\r\n  if (y < grid[0].length) {\r\n    if (cell.rightWall) {\r\n      if (\r\n        !grid[x][y + 1].start &&\r\n        !grid[x][y + 1].end &&\r\n        !grid[x + 1][y + 1].start &&\r\n        !grid[x + 1][y + 1].end\r\n      ) {\r\n        grid[x][y + 1].isWall = true;\r\n        grid[x + 1][y + 1].isWall = true;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst mergeSets = (\r\n  leftId: number,\r\n  rightId: number,\r\n  amountInSet: Map<number, number>,\r\n  cells: cell[]\r\n) => {\r\n  for (let i = 0; i < amountInSet.size - 1; i++) {\r\n    if (cells[i].id === rightId) {\r\n      cells[i].id = leftId;\r\n      amountInSet.set(leftId, amountInSet.get(leftId)! + 1);\r\n      amountInSet.set(rightId, amountInSet.get(rightId)! - 1);\r\n    }\r\n    if (amountInSet.get(rightId) === 0) {\r\n      break;\r\n    }\r\n  }\r\n};\r\n\r\nconst createUniqueSet = (amountsInSet: Map<number, number>, cell: cell) => {\r\n  if (cell.id >= 0) return;\r\n\r\n  for (let i = 0; i < amountsInSet.size - 1; i++) {\r\n    if (amountsInSet.get(i) === 0) {\r\n      cell.id = i;\r\n      amountsInSet.set(i, amountsInSet.get(i)! + 1);\r\n      break;\r\n    }\r\n  }\r\n};\r\nexport default generateMaze;\r\n","import styled from 'styled-components';\r\n\r\nconst Button = styled.button`\r\n  margin: 0px 5px 5px 5px;\r\n  font-family: Varela round;\r\n  position: relative;\r\n  min-width: 100px;\r\n  min-height: 40px;\r\n  padding: 5px 15px 5px 15px;\r\n  border-radius: 30px;\r\n  outline: none;\r\n  border: none;\r\n  color: #f5f5f5;\r\n  font-size: 20px;\r\n  font-weight: bold;\r\n  letter-spacing: 1px;\r\n  text-transform: uppercase;\r\n  background-color: #fd6868;\r\n  cursor: pointer;\r\n  transition: 0.08s;\r\n\r\n  &::after {\r\n    content: '';\r\n    border-radius: 30px;\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    left: 0;\r\n    bottom: 0;\r\n    box-shadow: inset 5px 5px 10px rgba(0, 0, 0, 0.3);\r\n    transition: 0.08s;\r\n    opacity: 0;\r\n  }\r\n  &:active::after {\r\n    opacity: 1;\r\n  }\r\n  &:hover {\r\n    box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.3);\r\n    transform: translate(-2px, -2px);\r\n  }\r\n`;\r\n\r\ninterface Props {\r\n  selection: string;\r\n  algorithmName: string;\r\n}\r\n\r\nconst SelectionButton = styled(Button)<Props>`\r\n  background-color: ${({ selection, algorithmName }) =>\r\n    selection === algorithmName ? '#3643f8' : '#fd6868'};\r\n`;\r\n\r\nconst ButtonGroup = styled.div`\r\n  width: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n`;\r\n\r\nconst ResetButtonGroup = styled(ButtonGroup)`\r\n  justify-content: flex-end;\r\n  padding-top: 5px;\r\n`;\r\n\r\nexport { Button, SelectionButton, ButtonGroup, ResetButtonGroup };\r\n","import React, { useState, useEffect } from 'react';\r\n\r\nimport Node from './DijkstraNode';\r\nimport { dijkstra } from '../../algorithms/dijkstra';\r\nimport { createGrid } from '../../helperFunctions';\r\nimport { GridComponent, GridCol } from '../gridComponents';\r\nimport generateMaze from '../../algorithms/mazeGenerator';\r\nimport { Button, ButtonGroup, ResetButtonGroup } from '../util';\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  distance: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst DijkstraGrid: React.FC = () => {\r\n  const [startNodeCoords, setStartNodeCoords] = useState({ x: 7, y: 1 });\r\n  const [endNodeCoords, setEndNodeCoords] = useState({ x: 7, y: 28 });\r\n\r\n  const createNode = (x: number, y: number): node => {\r\n    return {\r\n      start: x === startNodeCoords.y && y === startNodeCoords.x,\r\n      end: x === endNodeCoords.y && y === endNodeCoords.x,\r\n      x,\r\n      y,\r\n      weight: 1,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n      visited: false,\r\n      isWall: false,\r\n      shortest: false,\r\n    };\r\n  };\r\n\r\n  const [grid, setGrid] = useState(createGrid<node>(createNode));\r\n  const [isClicked, setIsClicked] = useState(false);\r\n  const [isWeight, setIsWeight] = useState(false);\r\n  const [isStart, setIsStart] = useState(false);\r\n  const [isEnd, setIsEnd] = useState(false);\r\n  const [isMaze, setIsMaze] = useState(false);\r\n  const [isAnimationComplete, setIsAnimationComplete] = useState(false);\r\n\r\n  const [startNode, setStartNode] = useState(\r\n    grid[startNodeCoords.x][startNodeCoords.y]\r\n  );\r\n  const [endNode, setEndNode] = useState(\r\n    grid[endNodeCoords.x][endNodeCoords.y]\r\n  );\r\n\r\n  useEffect(() => {\r\n    setStartNode(grid[startNodeCoords.x][startNodeCoords.y]);\r\n    setEndNode(grid[endNodeCoords.x][endNodeCoords.y]);\r\n    if (isMaze) {\r\n      generateMaze(grid);\r\n      setIsMaze(false);\r\n    }\r\n  }, [startNodeCoords, endNodeCoords, grid]);\r\n\r\n  const mouseDown = (x: number, y: number, isWeight: boolean) => {\r\n    setIsClicked(true);\r\n    grid[x][y].start ? setIsStart(true) : setIsStart(false);\r\n    grid[x][y].end ? setIsEnd(true) : setIsEnd(false);\r\n\r\n    if (grid[x][y].start || grid[x][y].end)\r\n      makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseEnter = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    if (isStart || isEnd) makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseUp = (x: number, y: number) => {\r\n    setIsClicked(false);\r\n    setIsStart(false);\r\n    setIsEnd(false);\r\n  };\r\n\r\n  const mouseLeave = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    resetNode(x, y, isStart, isEnd);\r\n  };\r\n\r\n  const resetNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      const newNode = { ...node, start: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      const newNode = { ...node, end: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const makeStartOrEndNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      setStartNodeCoords({ x, y });\r\n      const newNode = { ...node, start: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newNode,\r\n          newGrid[endNodeCoords.x][endNodeCoords.y]\r\n        );\r\n      }\r\n      return;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      setEndNodeCoords({ x, y });\r\n      const newNode = { ...node, end: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newGrid[startNodeCoords.x][startNodeCoords.y],\r\n          newNode\r\n        );\r\n      }\r\n      return;\r\n    }\r\n  };\r\n  const redrawAlgorithm = (grid: node[][], start: node, end: node) => {\r\n    emptyGrid();\r\n    const visitedNodes = dijkstra(grid, start, end);\r\n    const closestPath = getClosestPath(end);\r\n    for (let j = 0; j < closestPath!.length; j++) {\r\n      setGrid((currGrid) => {\r\n        const newGrid = [...currGrid];\r\n        const node = closestPath![j];\r\n        const end = {\r\n          ...node,\r\n          shortest: true,\r\n        };\r\n        newGrid[node.y][node.x] = end;\r\n        return newGrid;\r\n      });\r\n    }\r\n  };\r\n\r\n  const setNode = (x: number, y: number, isWeight: boolean) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (!isWeight) {\r\n      const newNode = { ...node, isWall: !node.isWall };\r\n      newGrid[x][y] = newNode;\r\n    } else {\r\n      let newNode;\r\n      node.weight > 1\r\n        ? (newNode = { ...node, weight: 1 })\r\n        : (newNode = { ...node, weight: 10 });\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isAnimationComplete) {\r\n      redrawAlgorithm(\r\n        newGrid,\r\n        newGrid[startNodeCoords.x][startNodeCoords.y],\r\n        newGrid[endNodeCoords.x][endNodeCoords.y]\r\n      );\r\n    }\r\n  };\r\n\r\n  const toggleWeight = () => {\r\n    setIsWeight(!isWeight);\r\n  };\r\n\r\n  const resetGrid = () => {\r\n    setGrid(createGrid<node>(createNode));\r\n    setStartNode(grid[startNodeCoords.x][startNodeCoords.y]);\r\n    setEndNode(grid[endNodeCoords.x][endNodeCoords.y]);\r\n    setIsAnimationComplete(false);\r\n  };\r\n\r\n  const getClosestPath = (endNode: node) => {\r\n    const closestPath: node[] = [];\r\n    let currNode: node | null = endNode;\r\n    while (currNode !== null) {\r\n      closestPath.unshift(currNode);\r\n      currNode = currNode.previousNode;\r\n    }\r\n    return closestPath;\r\n  };\r\n\r\n  const emptyGrid = () => {\r\n    const newGrid = [...grid];\r\n    newGrid.forEach((col) => {\r\n      col.forEach((node) => {\r\n        node.visited = false;\r\n        node.shortest = false;\r\n        node.distance = Infinity;\r\n        node.previousNode = null;\r\n      });\r\n    });\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const animateClosestPath = (closestPath: node[], i: number) => {\r\n    setTimeout(() => {\r\n      for (let j = 0; j < closestPath.length; j++) {\r\n        setTimeout(() => {\r\n          setGrid((grid) => {\r\n            const newGrid = [...grid];\r\n            const node = closestPath[j];\r\n            const newNode = {\r\n              ...node,\r\n              shortest: true,\r\n            };\r\n            newGrid[node.y][node.x] = newNode;\r\n            return newGrid;\r\n          });\r\n        }, 30 * j);\r\n      }\r\n      setIsAnimationComplete(true);\r\n    }, 30 * i);\r\n  };\r\n\r\n  const animateDijkstra = (visitedNodes: node[], i: number) => {\r\n    setTimeout(() => {\r\n      setGrid((grid) => {\r\n        const newGrid = [...grid];\r\n        const node = visitedNodes![i];\r\n        const newNode = {\r\n          ...node,\r\n          visited: true,\r\n        };\r\n        newGrid[node.y][node.x] = newNode;\r\n        return newGrid;\r\n      });\r\n    }, 30 * i);\r\n  };\r\n\r\n  const visualiseDijkstra = () => {\r\n    emptyGrid();\r\n    const visitedNodes = dijkstra(grid, startNode, endNode);\r\n    const closestPath = getClosestPath(endNode);\r\n    emptyGrid();\r\n    for (let i = 0; i < visitedNodes!.length; i++) {\r\n      if (i === visitedNodes!.length - 1) {\r\n        animateClosestPath(closestPath, i);\r\n      }\r\n      animateDijkstra(visitedNodes!, i);\r\n    }\r\n  };\r\n\r\n  const createMaze = () => {\r\n    setGrid(createGrid<node>(createNode));\r\n    setIsAnimationComplete(false);\r\n    setIsMaze(true);\r\n  };\r\n\r\n  let nodeObjectData: any = {\r\n    mouseDown,\r\n    mouseEnter,\r\n    mouseUp,\r\n    mouseLeave,\r\n    isWeight,\r\n  };\r\n  const weightOrWallText = isWeight ? 'weight' : 'wall';\r\n  return (\r\n    <>\r\n      <ButtonGroup>\r\n        <Button onClick={visualiseDijkstra}>Animate</Button>\r\n        <Button onClick={toggleWeight}>{weightOrWallText}</Button>\r\n        <Button onClick={createMaze}>maze</Button>\r\n      </ButtonGroup>\r\n      <GridComponent>\r\n        {grid.map((col, i) => (\r\n          <GridCol key={i}>\r\n            {col.map((node, j) => {\r\n              nodeObjectData = { ...nodeObjectData, ...node };\r\n              if (node.x === startNode.x && node.y === startNode.y)\r\n                return (\r\n                  <Node data={{ ...nodeObjectData, start: true }} key={j} />\r\n                );\r\n\r\n              if (node.x === endNode.x && node.y === endNode.y)\r\n                return <Node data={{ ...nodeObjectData, end: true }} key={j} />;\r\n\r\n              return <Node data={nodeObjectData} key={j} />;\r\n            })}\r\n          </GridCol>\r\n        ))}\r\n      </GridComponent>\r\n      <ResetButtonGroup>\r\n        <Button onClick={resetGrid}>reset</Button>\r\n      </ResetButtonGroup>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default DijkstraGrid;\r\n","import React, { useState, useEffect } from 'react';\r\nimport styled, { keyframes, css } from 'styled-components';\r\n\r\ninterface Props {\r\n  props: node;\r\n}\r\n\r\ninterface MainProps {\r\n  data: node;\r\n}\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  distance: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  mouseDown: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseEnter: (x: number, y: number, w: boolean, s: boolean) => void;\r\n  mouseUp: (x: number, y: number) => void;\r\n  mouseLeave: (\r\n    x: number,\r\n    y: number,\r\n    w: boolean,\r\n    s: boolean,\r\n    e: boolean\r\n  ) => void;\r\n  isWeight: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst NodeAnimation = keyframes`\r\n  0% {transform:scale(0)}\r\n  20% {transform:scale(0.3)}\r\n  40% {transform:scale(0.6)}\r\n  60% {transform:scale(0.9)}\r\n  80%{transform:scale(1.1)}\r\n  100%{transform:scale(1.0)}\r\n`;\r\n\r\nconst NodeOutline = styled.div`\r\n  width: 30px;\r\n  height: 30px;\r\n  margin: 1px;\r\n  user-select: none;\r\n  -webkit-user-drag: none;\r\n`;\r\n\r\nconst NodeComponent = styled.div<Props>`\r\n  position: relative;\r\n  background-color: ${(props) =>\r\n    props.props.start\r\n      ? 'green'\r\n      : props.props.end\r\n      ? 'red'\r\n      : props.props.isWall\r\n      ? 'pink'\r\n      : props.props.shortest\r\n      ? 'blue'\r\n      : props.props.weight > 1 && props.props.visited\r\n      ? 'gold'\r\n      : props.props.weight > 1\r\n      ? 'grey'\r\n      : props.props.visited\r\n      ? 'yellow'\r\n      : 'transparent'};\r\n  width: 100%;\r\n  height: 100%;\r\n  animation: ${(props) =>\r\n    props.props.start || props.props.end\r\n      ? `none`\r\n      : props.props.visited || props.props.shortest\r\n      ? css`\r\n          ${NodeAnimation} 1s linear\r\n        `\r\n      : `none`};\r\n`;\r\n\r\nconst ShortestNode = styled(NodeComponent)<Props>``;\r\n\r\nconst Node: React.FC<MainProps> = ({ data }) => {\r\n  const { x, y, isWeight, shortest, start, end } = data;\r\n\r\n  return (\r\n    <NodeOutline>\r\n      {(shortest && (\r\n        <ShortestNode\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            console.log(start);\r\n\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight, start, end);\r\n          }}\r\n        />\r\n      )) || (\r\n        <NodeComponent\r\n          props={{ ...data }}\r\n          onMouseDown={() => {\r\n            data.mouseDown(y, x, isWeight, start);\r\n          }}\r\n          onMouseEnter={() => {\r\n            data.mouseEnter(y, x, isWeight, start);\r\n          }}\r\n          onMouseUp={() => {\r\n            data.mouseUp(y, x);\r\n          }}\r\n          onMouseLeave={() => {\r\n            data.mouseLeave(y, x, isWeight, start, end);\r\n          }}\r\n        />\r\n      )}\r\n    </NodeOutline>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","interface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  gScore: number;\r\n  fScore: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n}\r\n\r\ntype grid = node[][];\r\n\r\nconst aStar = (grid: grid, start: node, end: node) => {\r\n  start.start = true;\r\n  end.end = true;\r\n  const openSet = new Set<node>();\r\n  const visitedNodes: node[] = [];\r\n  start.gScore = 0;\r\n  start.fScore = shortestDistance(grid, start, end);\r\n  openSet.add(start);\r\n  const closedSet = new Set<node>();\r\n\r\n  while (openSet.size > 0) {\r\n    const currentNode = sortNodesByClosest(Array.from(openSet)).shift();\r\n    if (currentNode === end) return visitedNodes;\r\n    currentNode!.visited = true;\r\n    visitedNodes.push(currentNode!);\r\n    openSet.delete(currentNode!);\r\n    closedSet.add(currentNode!);\r\n    const neighbours = getNeighbours(currentNode!, grid);\r\n    neighbours.forEach((neighbour) => {\r\n      if (neighbour.isWall || closedSet.has(neighbour)) {\r\n        return;\r\n      }\r\n      const tenativeGScore =\r\n        currentNode?.gScore! +\r\n        shortestDistance(grid, currentNode!, neighbour) +\r\n        neighbour.weight;\r\n      if (tenativeGScore < neighbour.gScore || !openSet.has(neighbour)) {\r\n        neighbour.previousNode = currentNode!;\r\n        neighbour.gScore = tenativeGScore;\r\n        neighbour.fScore =\r\n          neighbour.gScore + shortestDistance(grid, neighbour, end);\r\n        if (!openSet.has(neighbour)) openSet.add(neighbour);\r\n      }\r\n    });\r\n  }\r\n  return visitedNodes;\r\n};\r\n\r\nconst getNeighbours = (node: node, grid: grid) => {\r\n  const neighbours: node[] = [];\r\n  const { x, y } = node;\r\n\r\n  if (y < grid.length - 1) neighbours.push(grid[y + 1][x]);\r\n  if (y > 0) neighbours.push(grid[y - 1][x]);\r\n  if (x < grid[0].length - 1) neighbours.push(grid[y][x + 1]);\r\n  if (x > 0) neighbours.push(grid[y][x - 1]);\r\n  return neighbours;\r\n};\r\n\r\nconst sortNodesByClosest = (nodes: node[]) => {\r\n  return nodes.sort((a, b) => {\r\n    return a.fScore - b.fScore;\r\n  });\r\n};\r\n\r\nconst shortestDistance = (grid: grid, start: node, end: node) => {\r\n  var currNode = start;\r\n  var totalDist = 0;\r\n  while (currNode !== end) {\r\n    if (currNode.x > end.x) {\r\n      currNode = grid[currNode.y][currNode.x - 1];\r\n      totalDist += 1;\r\n    } else if (currNode.x < end.x) {\r\n      currNode = grid[currNode.y][currNode.x + 1];\r\n      totalDist += 1;\r\n    }\r\n    if (currNode.y > end.y) {\r\n      currNode = grid[currNode.y - 1][currNode.x];\r\n      totalDist += 1;\r\n    } else if (currNode.y < end.y) {\r\n      currNode = grid[currNode.y + 1][currNode.x];\r\n      totalDist += 1;\r\n    }\r\n  }\r\n  return totalDist;\r\n};\r\n\r\nexport { aStar };\r\n","import React, { useState, useEffect } from 'react';\r\nimport styled from 'styled-components';\r\n\r\nimport Node from './AStarNode';\r\nimport { aStar } from '../../algorithms/aStar';\r\nimport generateMaze from '../../algorithms/mazeGenerator';\r\nimport { createGrid } from '../../helperFunctions';\r\nimport { Button, ButtonGroup, ResetButtonGroup } from '../util';\r\n\r\nconst GridComponent = styled.div`\r\n  border: solid 1px;\r\n`;\r\n\r\nconst GridCol = styled.div`\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n`;\r\n\r\ninterface node {\r\n  start: boolean;\r\n  end: boolean;\r\n  x: number;\r\n  y: number;\r\n  weight: number;\r\n  gScore: number;\r\n  fScore: number;\r\n  previousNode: node | null;\r\n  visited: boolean;\r\n  isWall: boolean;\r\n  shortest?: boolean;\r\n}\r\n\r\nconst AStarGrid: React.FC = () => {\r\n  const [startNodeCoords, setStartNodeCoords] = useState({ x: 7, y: 1 });\r\n  const [endNodeCoords, setEndNodeCoords] = useState({ x: 7, y: 28 });\r\n\r\n  const createNode = (x: number, y: number): node => {\r\n    return {\r\n      start: x === startNodeCoords.y && y === startNodeCoords.x,\r\n      end: x === endNodeCoords.y && y === endNodeCoords.x,\r\n      x,\r\n      y,\r\n      weight: 0,\r\n      gScore: Infinity,\r\n      fScore: Infinity,\r\n      previousNode: null,\r\n      visited: false,\r\n      isWall: false,\r\n      shortest: false,\r\n    };\r\n  };\r\n\r\n  const [grid, setGrid] = useState(createGrid<node>(createNode));\r\n  const [isClicked, setIsClicked] = useState(false);\r\n  const [isWeight, setIsWeight] = useState(false);\r\n  const [isStart, setIsStart] = useState(false);\r\n  const [isEnd, setIsEnd] = useState(false);\r\n  const [isMaze, setIsMaze] = useState(false);\r\n  const [isAnimationComplete, setIsAnimationComplete] = useState(false);\r\n\r\n  const [startNode, setStartNode] = useState(\r\n    grid[startNodeCoords.x][startNodeCoords.y]\r\n  );\r\n  const [endNode, setEndNode] = useState(\r\n    grid[endNodeCoords.x][endNodeCoords.y]\r\n  );\r\n\r\n  useEffect(() => {\r\n    setStartNode(grid[startNodeCoords.x][startNodeCoords.y]);\r\n    setEndNode(grid[endNodeCoords.x][endNodeCoords.y]);\r\n    if (isMaze) {\r\n      generateMaze(grid);\r\n      setIsMaze(false);\r\n    }\r\n  }, [startNodeCoords, endNodeCoords, grid]);\r\n\r\n  const mouseDown = (x: number, y: number, isWeight: boolean) => {\r\n    setIsClicked(true);\r\n    grid[x][y].start ? setIsStart(true) : setIsStart(false);\r\n    grid[x][y].end ? setIsEnd(true) : setIsEnd(false);\r\n    if (grid[x][y].start || grid[x][y].end)\r\n      makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseEnter = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    if (isStart || isEnd) makeStartOrEndNode(x, y, isStart, isEnd);\r\n    else setNode(x, y, isWeight);\r\n  };\r\n\r\n  const mouseUp = (x: number, y: number) => {\r\n    setIsClicked(false);\r\n    setIsStart(false);\r\n    setIsEnd(false);\r\n  };\r\n\r\n  const mouseLeave = (x: number, y: number, isWeight: boolean) => {\r\n    if (!isClicked) return;\r\n    resetNode(x, y, isStart, isEnd);\r\n  };\r\n\r\n  const resetNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      const newNode = { ...node, start: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      const newNode = { ...node, end: false };\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const makeStartOrEndNode = (\r\n    x: number,\r\n    y: number,\r\n    isStart: boolean,\r\n    isEnd: boolean\r\n  ) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (isStart) {\r\n      if (node.end) return;\r\n      setStartNodeCoords({ x, y });\r\n      const newNode = { ...node, start: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newNode,\r\n          newGrid[endNodeCoords.x][endNodeCoords.y]\r\n        );\r\n      }\r\n      return;\r\n    }\r\n    if (isEnd) {\r\n      if (node.start) return;\r\n      setEndNodeCoords({ x, y });\r\n      const newNode = { ...node, end: true };\r\n      newGrid[x][y] = newNode;\r\n      if (isAnimationComplete) {\r\n        redrawAlgorithm(\r\n          newGrid,\r\n          newGrid[startNodeCoords.x][startNodeCoords.y],\r\n          newNode\r\n        );\r\n      }\r\n      return;\r\n    }\r\n  };\r\n\r\n  const setNode = (x: number, y: number, isWeight: boolean) => {\r\n    const newGrid = [...grid];\r\n    const node = newGrid[x][y];\r\n    if (!isWeight) {\r\n      const newNode = { ...node, isWall: !node.isWall };\r\n      newGrid[x][y] = newNode;\r\n    } else {\r\n      let newNode;\r\n      node.weight > 0\r\n        ? (newNode = { ...node, weight: 0 })\r\n        : (newNode = { ...node, weight: 10 });\r\n      newGrid[x][y] = newNode;\r\n    }\r\n    if (isAnimationComplete) {\r\n      redrawAlgorithm(\r\n        newGrid,\r\n        newGrid[startNodeCoords.x][startNodeCoords.y],\r\n        newGrid[endNodeCoords.x][endNodeCoords.y]\r\n      );\r\n    }\r\n  };\r\n\r\n  const toggleWeight = () => {\r\n    setIsWeight(!isWeight);\r\n  };\r\n\r\n  const resetGrid = () => {\r\n    setIsAnimationComplete(false);\r\n    setGrid(createGrid<node>(createNode));\r\n  };\r\n\r\n  const getClosestPath = (endNode: node) => {\r\n    const closestPath: node[] = [];\r\n    let currNode: node | null = endNode;\r\n    while (currNode !== null) {\r\n      closestPath.unshift(currNode);\r\n      currNode = currNode.previousNode;\r\n    }\r\n    return closestPath;\r\n  };\r\n\r\n  const emptyGrid = () => {\r\n    const newGrid = [...grid];\r\n    newGrid.forEach((col) => {\r\n      col.forEach((node) => {\r\n        node.visited = false;\r\n        node.shortest = false;\r\n        node.shortest = false;\r\n        node.fScore = Infinity;\r\n        node.gScore = Infinity;\r\n        node.previousNode = null;\r\n      });\r\n    });\r\n    setGrid(newGrid);\r\n  };\r\n\r\n  const animateClosestPath = (closestPath: node[], i: number) => {\r\n    setTimeout(() => {\r\n      for (let j = 0; j < closestPath.length; j++) {\r\n        setTimeout(() => {\r\n          setGrid((grid) => {\r\n            const newGrid = [...grid];\r\n            const node = closestPath[j];\r\n            const newNode = {\r\n              ...node,\r\n              shortest: true,\r\n            };\r\n            newGrid[node.y][node.x] = newNode;\r\n            return newGrid;\r\n          });\r\n        }, 50 * j);\r\n      }\r\n      setIsAnimationComplete(true);\r\n    }, 50 * i);\r\n  };\r\n\r\n  const animateAStar = (visitedNodes: node[], i: number) => {\r\n    setTimeout(() => {\r\n      setGrid((grid) => {\r\n        const newGrid = [...grid];\r\n        const node = visitedNodes![i];\r\n        const newNode = {\r\n          ...node,\r\n          visited: true,\r\n        };\r\n        newGrid[node.y][node.x] = newNode;\r\n        return newGrid;\r\n      });\r\n    }, 50 * i);\r\n  };\r\n\r\n  const visualiseAStar = () => {\r\n    emptyGrid();\r\n    const visitedNodes = aStar(grid, startNode, endNode);\r\n    const closestPath = getClosestPath(endNode);\r\n    emptyGrid();\r\n    for (let i = 0; i < visitedNodes!.length; i++) {\r\n      if (i === visitedNodes!.length - 1) {\r\n        animateClosestPath(closestPath, i);\r\n      }\r\n      animateAStar(visitedNodes!, i);\r\n    }\r\n  };\r\n\r\n  const redrawAlgorithm = (grid: node[][], start: node, end: node) => {\r\n    emptyGrid();\r\n    const visitedNodes = aStar(grid, start, end);\r\n    console.log(grid);\r\n    const closestPath = getClosestPath(end);\r\n    for (let j = 0; j < closestPath!.length; j++) {\r\n      setGrid((currGrid) => {\r\n        const newGrid = [...currGrid];\r\n        const node = closestPath![j];\r\n        const end = {\r\n          ...node,\r\n          shortest: true,\r\n        };\r\n        newGrid[node.y][node.x] = end;\r\n        return newGrid;\r\n      });\r\n    }\r\n  };\r\n\r\n  let nodeObjectData: any = {\r\n    mouseDown,\r\n    mouseEnter,\r\n    mouseUp,\r\n    mouseLeave,\r\n    isWeight,\r\n  };\r\n\r\n  const createMaze = () => {\r\n    setGrid(createGrid<node>(createNode));\r\n    setIsAnimationComplete(false);\r\n    setIsMaze(true);\r\n  };\r\n  const weightOrWallText = isWeight ? 'weight' : 'wall';\r\n\r\n  return (\r\n    <>\r\n      <ButtonGroup>\r\n        <Button onClick={visualiseAStar}>Animate</Button>\r\n        <Button onClick={toggleWeight}>{weightOrWallText}</Button>\r\n        <Button onClick={createMaze}>maze</Button>\r\n      </ButtonGroup>\r\n      <GridComponent>\r\n        {grid.map((col, i) => (\r\n          <GridCol key={i}>\r\n            {col.map((node, j) => {\r\n              nodeObjectData = { ...nodeObjectData, ...node };\r\n              if (node.x === startNode.x && node.y === startNode.y)\r\n                return (\r\n                  <Node data={{ ...nodeObjectData, start: true }} key={j} />\r\n                );\r\n\r\n              if (node.x === endNode.x && node.y === endNode.y)\r\n                return <Node data={{ ...nodeObjectData, end: true }} key={j} />;\r\n\r\n              return <Node data={nodeObjectData} key={j} />;\r\n            })}\r\n          </GridCol>\r\n        ))}\r\n      </GridComponent>\r\n      <ResetButtonGroup>\r\n        <Button onClick={resetGrid}>reset</Button>\r\n      </ResetButtonGroup>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default AStarGrid;\r\n","import { createGlobalStyle } from 'styled-components';\r\n\r\nexport const GlobalStyles = createGlobalStyle`\r\n  *,\r\n  *::after,\r\n  *::before {\r\n    box-sizing: border-box;\r\n  }\r\n  html, body, #root{\r\n    margin: 0;\r\n    padding: 0;    \r\n  }\r\n    \r\n  `;\r\n","import React, { useState } from 'react';\nimport styled from 'styled-components';\n\nimport DijkstraGrid from './components/dijkstra/DijkstraGrid';\nimport AStarGrid from './components/astar/AStarGrid';\nimport { SelectionButton, ButtonGroup } from './components/util';\nimport { GlobalStyles } from './global';\n\nconst MainContainer = styled.div`\n  font-family: Georgia, 'Times New Roman', Times, serif;\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  height: 100vh;\n`;\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n`;\n\nfunction App() {\n  const [currGrid, setCurrGrid] = useState('dijkstra');\n\n  const setDijkstra = () => {\n    setCurrGrid('dijkstra');\n  };\n\n  const setAStar = () => {\n    setCurrGrid('astar');\n  };\n\n  return (\n    <>\n      <GlobalStyles />\n      <MainContainer>\n        <Container>\n          <ButtonGroup>\n            <SelectionButton\n              selection={currGrid}\n              algorithmName='dijkstra'\n              onClick={setDijkstra}\n            >\n              dijkstra\n            </SelectionButton>\n            <SelectionButton\n              selection={currGrid}\n              algorithmName='astar'\n              onClick={setAStar}\n            >\n              a*\n            </SelectionButton>\n          </ButtonGroup>\n          {currGrid === 'dijkstra' && <DijkstraGrid />}\n          {currGrid === 'astar' && <AStarGrid />}\n          <br />\n          <h3>\n            * Switch between algorithms by clicking on the respective button\n            <br />\n            * Click the wall button to change to a weight and vice versa\n            <br />\n            * Click anywhere in the grid to place a wall or weight\n            <br />* Click the maze button to generate a maze\n            <br />* Click the reset button to reset the grid\n          </h3>\n        </Container>\n      </MainContainer>\n    </>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}